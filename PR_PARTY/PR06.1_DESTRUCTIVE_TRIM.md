# PR#6.1: Destructive Trim Implementation

**Estimated Time:** 4-6 hours  
**Complexity:** MEDIUM-HIGH  
**Priority:** Critical - Improves Trim UX  
**Dependencies:** PR #6 (current trim system)  
**Type:** Major Refactoring

---

## Overview

### What We're Building
A destructive trim system where trimming a clip immediately creates a new trimmed video file, replaces the original clip in the timeline with the shorter version, and updates the UI to reflect only the trimmed segment. This matches intuitive video editing (iMovie, Apple Photos) where "trimming" actually removes parts of the video.

### Why It Matters
The current non-destructive trim system (marks) is confusing because:
- Video still shows full length during playback
- Timeline doesn't reflect actual project length
- Users expect "trim" to permanently delete excess footage
- Export doesn't feel representative of what they see

This refactor makes ClipForge intuitive: what you see is what you get.

### Success in One Sentence
"This PR is successful when trimming a clip permanently deletes the excess footage, the player only shows the trimmed segment (0 to new duration), and the timeline displays the actual trimmed clip length."

---

## Technical Design

### Architecture Decisions

#### Decision 1: Destructive vs Non-Destructive
**Options Considered:**
1. **Keep marks (current)** - Trim marks in state, apply on export
2. **Destructive trim** - Permanently trim when user confirms
3. **Virtual segments** - Render preview, apply on export

**Chosen:** Option 2 - Destructive Trim

**Rationale:**
- Most intuitive for end users
- What you see is what you get
- Matches iMovie/Photos behavior
- Timeline shows actual project
- Simple mental model

**Trade-offs:**
- Gain: Intuitive UX, clear state
- Lose: Original footage lost (unless we keep backup)
- Mitigation: Add undo/redo feature later

#### Decision 2: When to Render Trimmed Clip
**Options Considered:**
1. **Render on confirm** - User clicks "Apply Trim" button
2. **Render on drag end** - Automatic when user releases slider
3. **Render on selection change** - Render when switching clips
4. **Lazy render** - Only render on export

**Chosen:** Option 1 - Render on confirm

**Rationale:**
- Clear user intent ("I'm done trimming")
- Can abort if wrong
- Prevents accidental renders
- User knows when processing happens

**Trade-offs:**
- Gain: Clear workflow, no surprises
- Lose: Extra click
- Mitigation: Add visual feedback during render

#### Decision 3: Where to Store Trimmed Files
**Options Considered:**
1. **Replace original** - Overwrite source file
2. **Temp directory** - Store in app data, cleanup on exit
3. **Same directory** - Create `clip_t trimmed.mp4` beside original
4. **Dedicated cache** - `clipforge-trims/clip_id.mp4`

**Chosen:** Option 2 - Temp directory with cleanup

**Rationale:**
- Preserves originals (can re-import if needed)
- Clean app data structure
- Easy to manage cache size
- Can implement "undo" later

**Trade-offs:**
- Gain: Non-destructive of source files
- Lose: Disk space during editing
- Mitigation: Cleanup on app exit

#### Decision 4: UI Workflow
**Options Considered:**
1. **Auto-render** - Render immediately when trimming done
2. **Confirm button** - User clicks "Apply Trim" to render
3. **Draft/Applied states** - Show draft marks, apply on button
4. **Live render** - Preview while dragging handles

**Chosen:** Option 2 + Draft/Applied hybrid

**Rationale:**
- Draft shows trim marks visually
- Clear separation: "I'm setting trim" vs "I'm applying it"
- Can fine-tune before committing
- Visual feedback shows what will happen

**UI Flow:**
```
1. User drags handles (draft state)
2. Trim marks visible on timeline + slider
3. User clicks "Apply Trim" button
4. Processing indicator shows
5. Trimmed clip replaces original
6. Timeline shows new shorter clip
7. Done!
```

### Data Model Changes

**Current State:**
```javascript
clips = [
  { id: 'clip-1', name: 'video.mp4', path: '/path/video.mp4', duration: 120 }
]
clipTrims = {
  'clip-1': { inPoint: 10, outPoint: 40 }
}
// Export uses trim marks to slice
```

**New State (Destructive):**
```javascript
clips = [
  { 
    id: 'clip-1', 
    name: 'video.mp4', 
    path: '/path/video.mp4',
    trimmedPath: '/temp/clip-1_trimmed.mp4',  // ← New
    originalDuration: 120,  // ← Preserve for undo
    duration: 30,  // ← Updated to trimmed length
    isTrimmed: true,
    trimStartOffset: 10,  // ← Original start point
  }
]
// Playback uses trimmedPath when isTrimmed=true
// Timeline shows updated duration
// Export uses current clip path
```

**State Transition:**
```
Before Trim:
clip.duration = 120 (original)
clip.path = '/original/video.mp4'

User Sets Trim: inPoint=10, outPoint=40

Click "Apply Trim":
1. Render: video.mp4[10s-40s] → /temp/clip-1_trimmed.mp4
2. Update clip:
   - trimmedPath = '/temp/clip-1_trimmed.mp4'
   - isTrimmed = true
   - duration = 30
   - trimStartOffset = 10
3. Player uses trimmedPath
4. Timeline shows 30s clip
```

### Component Changes

**VideoPlayer.js:**
- Accept `trimmedPath` prop
- Use trimmed path when available
- Show video as if trimmed at 0:00 (not offset)

**Timeline.js:**
- Display `clip.duration` (already trimmed length)
- No trim overlays needed (already applied)
- Width based on actual duration

**TrimControls.js:**
- Add "Apply Trim" button
- Show draft state visually
- Disable slider after apply
- Update label to "Trimming..." during render

**ExportPanel.js:**
- Use `clip.path` (already trimmed)
- No trim data needed (already applied)

**App.js:**
- Add `handleApplyTrim()` function
- Trigger FFmpeg render
- Update clip state after render
- Handle render progress

### Rendering Process

**Step 1: User Confirms Trim**
```javascript
handleApplyTrim() {
  const clip = selectedClip;
  const trimData = clipTrims[clip.id];
  
  // Show processing UI
  setTrimmingInProgress(true);
  
  // Render trimmed clip
  await window.electronAPI.renderTrimmedClip(
    clip.path,
    '/temp/clip-trimmed.mp4',
    trimData
  );
  
  // Update clip state
  setClips(prev => prev.map(c =>
    c.id === clip.id
      ? {
          ...c,
          trimmedPath: '/temp/clip-trimmed.mp4',
          isTrimmed: true,
          duration: trimData.outPoint - trimData.inPoint,
          trimStartOffset: trimData.inPoint,
          path: '/temp/clip-trimmed.mp4' // Now uses trimmed
        }
      : c
  ));
  
  setTrimmingInProgress(false);
}
```

**Step 2: FFmpeg Rendering**
```javascript
// electron/ffmpeg/videoProcessing.js
async function renderTrimmedClip(inputPath, outputPath, trimData) {
  return new Promise((resolve, reject) => {
    const startTime = trimData.inPoint;
    const duration = trimData.outPoint - trimData.inPoint;
    
    ffmpeg(inputPath)
      .setStartTime(startTime)
      .setDuration(duration)
      .videoCodec('libx264')
      .audioCodec('aac')
      .outputOptions(['-preset ultrafast']) // Fast for MVP
      .on('progress', (progress) => {
        // Emit progress to renderer
      })
      .on('end', () => resolve(outputPath))
      .on('error', reject)
      .save(outputPath);
  });
}
```

**Step 3: Update UI**
```javascript
// Player now shows trimmed clip as 0:00-0:30
// Timeline shows 30s clip
// Export uses trimmed clip directly
```

---

## Implementation Details

### New Files

```
electron/
├── ffmpeg/
│   └── videoProcessing.js (+ trim rendering function)

src/
├── components/
│   └── TrimControls.js (add Apply button)
└── utils/
    └── fileHelpers.js (add temp path generation)
```

### Modified Files

- `src/App.js` (+60 lines) - Add apply trim logic
- `src/components/VideoPlayer.js` (+20 lines) - Use trimmed path
- `src/components/Timeline.js` (-40 lines) - Remove trim overlays
- `src/components/ExportPanel.js` (-10 lines) - Simplify (no trim data)
- `main.js` (+30 lines) - Add render handler
- `preload.js` (+5 lines) - Expose render API

### Key Implementation Steps

#### Phase 1: Add Apply Button (30 min)
1. Add "Apply Trim" button to TrimControls
2. Add disabled state (no trim marks set)
3. Add visual draft state indicator
4. Wire up to App.js handler

#### Phase 2: Rendering Functionality (2 hours)
1. Create `renderTrimmedClip()` in videoProcessing.js
2. Add IPC handler in main.js
3. Add preload API exposure
4. Add progress reporting
5. Handle temp file cleanup
6. Test rendering works

#### Phase 3: State Update Logic (1 hour)
1. Implement `handleApplyTrim()` in App.js
2. Update clip state after render
3. Swap to trimmed path
4. Update duration display
5. Reset trim marks after apply
6. Handle render errors

#### Phase 4: Player Integration (30 min)
1. Player uses trimmed path when available
2. Player shows as starting at 0:00
3. Update duration display
4. Remove trim boundary checks (no longer needed)

#### Phase 5: Timeline Cleanup (30 min)
1. Remove trim overlay rendering
2. Update width based on actual duration
3. Show trimmed clip as complete clip
4. Update total duration calculation

#### Phase 6: Export Simplification (30 min)
1. Remove trim data from export
2. Export uses current clip path directly
3. No FFmpeg trim needed (already trimmed)
4. Simplify export flow

#### Phase 7: Testing & Polish (1 hour)
1. Test full workflow
2. Test multi-clip trimming
3. Test render progress display
4. Test error handling
5. Test temp file cleanup
6. Add visual feedback during render

---

## Code Examples

### Example 1: Apply Trim Handler
```javascript
// src/App.js
const handleApplyTrim = async () => {
  if (!selectedClip) return;
  
  const trimData = clipTrims[selectedClip.id];
  if (!trimData || trimData.inPoint >= trimData.outPoint) {
    setError('Invalid trim settings');
    return;
  }

  try {
    setIsRendering(true);
    setRenderProgress(0);
    
    // Generate temp path
    const tempPath = path.join(
      app.getPath('temp'), 
      `clipforge-trims/${selectedClip.id}_trimmed.mp4`
    );
    
    // Render trimmed clip
    const result = await window.electronAPI.renderTrimmedClip(
      selectedClip.path,
      tempPath,
      trimData
    );
    
    if (result.success) {
      // Update clip to use trimmed version
      setClips(prev => prev.map(clip =>
        clip.id === selectedClip.id
          ? {
              ...clip,
              trimmedPath: tempPath,
              isTrimmed: true,
              duration: trimData.outPoint - trimData.inPoint,
              trimStartOffset: trimData.inPoint
            }
          : clip
      ));
      
      // Update selected clip
      setSelectedClip(prev => ({
        ...prev,
        trimmedPath: tempPath,
        isTrimmed: true,
        duration: trimData.outPoint - trimData.inPoint,
        trimStartOffset: trimData.inPoint
      }));
      
      // Clear trim marks (now applied)
      setClipTrims(prev => {
        const next = { ...prev };
        delete next[selectedClip.id];
        return next;
      });
      
      setStatus('Trim applied successfully');
    }
  } catch (error) {
    console.error('Apply trim error:', error);
    setError('Failed to apply trim');
  } finally {
    setIsRendering(false);
    setRenderProgress(0);
  }
};
```

### Example 2: Render Function
```javascript
// electron/ffmpeg/videoProcessing.js
async function renderTrimmedClip(inputPath, outputPath, trimData, onProgress) {
  return new Promise((resolve, reject) => {
    const startTime = trimData.inPoint || 0;
    const duration = trimData.outPoint - trimData.inPoint;
    
    console.log(`Rendering trimmed clip: ${startTime}s - ${trimData.outPoint}s`);
    console.log(`Output: ${outputPath}`);
    
    // Ensure temp directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    ffmpeg(inputPath)
      .setStartTime(startTime)
      .setDuration(duration)
      .videoCodec('libx264')
      .audioCodec('aac')
      .outputOptions([
        '-preset ultrafast',  // Fast for MVP
        '-crf 23',
        '-avoid_negative_ts make_zero'
      ])
      .on('progress', (progress) => {
        console.log('Render progress:', progress.percent + '%');
        if (onProgress) {
          onProgress({
            percent: progress.percent || 0,
            timemark: progress.timemark || '00:00:00'
          });
        }
      })
      .on('end', () => {
        console.log('Trimmed clip rendered successfully');
        resolve(outputPath);
      })
      .on('error', (err) => {
        console.error('FFmpeg render error:', err);
        reject(new Error(`Failed to render trimmed clip: ${err.message}`));
      })
      .save(outputPath);
  });
}
```

### Example 3: Player Uses Trimmed Path
```javascript
// src/components/VideoPlayer.js
const VideoPlayer = ({ videoSrc, onTimeUpdate, selectedClip, trimData }) => {
  // Use trimmed path if available
  const effectivePath = selectedClip?.trimmedPath || videoSrc;
  
  // Player doesn't need trim boundaries anymore
  // (clip is already trimmed)
  
  return (
    <video src={effectivePath} />
  );
};
```

### Example 4: IPC Handler
```javascript
// main.js
ipcMain.handle('render-trimmed-clip', async (event, inputPath, outputPath, trimData) => {
  try {
    console.log('Render trim request:', { inputPath, outputPath, trimData });
    
    await renderTrimmedClip(inputPath, outputPath, trimData, (progress) => {
      // Send progress to renderer
      event.sender.send('render-progress-update', progress);
    });
    
    return { success: true, outputPath };
  } catch (error) {
    console.error('Render trim error:', error);
    return { success: false, error: error.message };
  }
});
```

### Example 5: Export Simplification
```javascript
// src/components/ExportPanel.js
const handleExport = async () => {
  const clipsToExport = allClips.filter(c => c.isTrimmed || !clipTrims[c.id]);
  
  // Export each clip (already trimmed)
  for (const clip of clipsToExport) {
    const filePath = clip.trimmedPath || clip.path;
    
    await window.electronAPI.exportVideo(
      filePath,
      outputPath,
      {} // No trim data needed
    );
  }
};
```

---

## Testing Strategy

### Test Categories

**Unit Tests:**
- Render function creates correct FFmpeg command
- State update logic preserves clip metadata
- Temp path generation is unique
- Error handling catches render failures

**Integration Tests:**
- Set trim → Apply trim → Clip becomes shorter
- Player shows trimmed segment starting at 0:00
- Timeline reflects new duration
- Export produces trimmed video
- Switching clips preserves trimmed state

**Edge Cases:**
- Trim to 0 duration (should prevent)
- Trim entire clip (should keep full length)
- Render fails mid-way (should recover)
- Multiple clips trimmed (all should work)
- Undo trim (later feature)

**Performance Tests:**
- Render time for 30s clip < 5 seconds
- No memory leaks during render
- Temp files cleaned up properly
- UI remains responsive during render

---

## Success Criteria

### Hard Requirements (Must Pass)
- [ ] Apply button renders trimmed clip
- [ ] Trimmed clip replaces original in timeline
- [ ] Player shows trimmed clip (starting at 0:00)
- [ ] Timeline shows correct new duration
- [ ] Export produces trimmed video
- [ ] Render progress shows during processing
- [ ] Trim marks cleared after apply

### Quality Indicators (Should Pass)
- [ ] Render completes in reasonable time (<10s)
- [ ] Visual feedback during render is clear
- [ ] Error messages helpful if render fails
- [ ] Temp files cleaned up properly
- [ ] UI doesn't freeze during render

---

## Risk Assessment

### Risk 1: Render Performance
**Likelihood:** MEDIUM  
**Impact:** HIGH  
**Mitigation:** Use ultrafast preset for MVP, add progress feedback  
**Status:** 🟡 Medium Risk

### Risk 2: Temp File Management
**Likelihood:** MEDIUM  
**Impact:** MEDIUM  
**Mitigation:** Implement cleanup on app exit, track temp files  
**Status:** 🟡 Medium Risk

### Risk 3: State Consistency
**Likelihood:** HIGH  
**Impact:** HIGH  
**Mitigation:** Careful state updates, test thoroughly  
**Status:** 🔴 High Risk

### Risk 4: User Expectation Mismatch
**Likelihood:** LOW  
**Impact:** MEDIUM  
**Mitigation:** Clear UI feedback ("Applying trim..." → "Done")  
**Status:** 🟢 Low Risk

---

## Timeline Estimates

**Total Time:** 4-6 hours

| Phase | Task | Time | Priority |
|-------|------|------|----------|
| 1 | Add Apply button | 30 min | HIGH |
| 2 | Rendering function | 2 hours | CRITICAL |
| 3 | State updates | 1 hour | CRITICAL |
| 4 | Player integration | 30 min | HIGH |
| 5 | Timeline cleanup | 30 min | HIGH |
| 6 | Export simplification | 30 min | MEDIUM |
| 7 | Testing & polish | 1 hour | HIGH |

**Buffer:** 1 hour for unexpected issues

---

## Comparison with Other Editors

### iMovie
- Destructive trim ✓
- Instant feedback ✓
- Can undo ✓
- **What we're matching**

### Premiere Pro
- Non-destructive ✓
- Apply on export
- More complex
- **What we're NOT matching**

### Apple Photos
- Destructive trim ✓
- Simple workflow ✓
- Intuitive ✓
- **What we're matching**

---

## User Workflow (After This PR)

```
1. Import video (120 seconds)
   → Timeline shows 120s clip

2. Drag IN handle to 10s
   → Draft trim mark at 10s
   → Slider shows "In: 00:10"

3. Drag OUT handle to 40s
   → Draft trim mark at 40s
   → Slider shows "Out: 00:40"
   → Shows "Duration: 00:30"

4. Click "Apply Trim" button
   → UI shows "Rendering..."
   → Progress bar fills (0-100%)
   → FFmpeg creates trimmed file

5. Trim applied ✓
   → Timeline shows 30s clip (not 120s)
   → Player shows 0:00-0:30 (trimmed clip)
   → Export produces 30s video

6. Import another clip
   → Can trim it independently
   → Each clip maintains its trimmed state

7. Export
   → Exports all clips as trimmed
```

---

## Future Enhancements

### Undo/Redo
- Store original paths for undo
- Add "Undo Trim" button
- Restore to original duration

### Batch Trimming
- Trim multiple clips at once
- Apply to all selected clips

### Trim Preview
- Show preview before applying
- Faster preview render (lower quality)

### Optimizations
- Lazy render (only on export)
- Background rendering
- Cache trimmed clips

---

**Document Status:** Planning Complete  
**Next Action:** Review and create implementation checklist

